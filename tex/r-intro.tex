\chapter{Getting started with \R~\label{ch:introR}}

\boxx{
	In this chapter I will focus on getting you started typing \R\ commands. Our goal in this chapter is not to learn any statistical concepts: we're just trying to learn the basics of how \R\ works and get comfortable interacting with the system. To do this, we'll spend a bit of time using \R\ as a simple calculator and you'll get a bit of a feel for what it's like to work in \R. From there I'll introduce some very basic programming ideas: in particular, I'll talk about the idea of defining {\it variables} to store information, and a few things that you can do with these variables. 
}



%\pagestyle{fancy}



\pbn
\section{Typing commands at the \R\ console}\label{sec:firstcommand}

One of the easiest things you can do with \R\ is use it as a simple calculator, so it's a good place to start. For instance, try typing \rtext{10 + 20}, and hitting enter.\FOOTNOTE{Seriously. If you're in a position to do so, open up \R\ and start typing. The simple act of typing it rather than ``just reading'' makes a big difference. It makes the concepts more concrete, and it ties the abstract ideas (programming and statistics) to the actual context in which you need to use them. Statistics is something you {\it do}, not just something you read about in a textbook.} When you do this, you've entered a \keyterm{command}, and \R\ will ``execute'' that command. What you see on screen now will be this:
\begin{rblock1}
> @usr{10 + 20}
[1] 30
\end{rblock1}
The \rtextoutput{>} symbol is just the \R\ command prompt and isn't part of the actual command.
The \rtextoutput{[1]} part just means  ``the answer to the 1st question you asked is 30''.



\subsection{Be very careful to avoid typos}

While \R\ is good software, it is still kind of stupid as it can't handle typos. It takes it on faith that you meant to type {\it exactly} what you did type. For example, suppose that you type \rtext{10 = 20} rather than \rtext{10 + 20}. Here's what happens:
\begin{rblock1}
> @usr{10 = 20}
Error in 10 = 20 : invalid (do_set) left-hand side to assignment
\end{rblock1}
What's happened here is that \R\ has attempted to interpret \rtext{10 = 20} as a command, and spits out an error message because the command doesn't make any sense to it. 
To some extent, I'm stating the obvious here, but it's important. The people who wrote \R\ are smart. You, the user, are smart. But \R\ itself is dumb. And because it's dumb, it has to be mindlessly obedient. It does {\it exactly} what you ask it to do. There is  no equivalent to ``autocorrect'' in \R. 

Moreover, consider that \textbf{\R is case-sensitive}. That means it makes a difference whether you use capital letters or not.

\subsection{\R\ is (a bit) flexible with spacing}

Albeit I stated that \R\ is dumb. It is smart enough to ignore redundant spacing. For example,  when I typed \rtext{10 + 20} before, I could equally have done this
\begin{rblock1}
> @usr{10    + 20}
[1] 30
\end{rblock1}
or this 
\begin{rblock1}
> @usr{10+20}
[1] 30
\end{rblock1}
and I would get exactly the same answer. However, that doesn't mean that you can insert spaces in any place. For example, you cannot insert spaces in the middle of a function:
\begin{rblock1}
> @usr{setw d()}
Error: unexpected symbol in "setw d"
\end{rblock1}


\subsection{\R\ sometimes knows that you're not finished yet}

If you type \rtext{10 + } and then press enter, \R\ is smart enough to realize that you probably wanted to type in another number. So here's what happens:
\begin{rblock1}
> @usr{10+}
+ 
\end{rblock1}
and there's a blinking cursor next to the plus sign. \R\ ``thinks'' you're still typing your command, so it hasn't tried to execute it yet. Thus, this plus sign is actually another command prompt. It's different from the usual one (i.e., the \rtextoutput{>} symbol). If I then go on to type \rtext{20} and hit enter, what I get is this:
\begin{rblock1}
> @usr{10+}
+ @usr{20}
[1] 30
\end{rblock1}
 Similarly, when you forgot to close the bracket \R\ reminds you to do so:
\begin{rblock1}
	> @usr{getwd(}
	+ 
	+ 
	+ @usr{)}
\end{rblock1} 
 


\section{Doing simple calculations with \R~}\label{sec:arithmetic}


\subsection{Adding, subtracting, multiplying and dividing}

%\index{R}{{+}}
%\index{R}{{-}}
%\index{R}{{*}}
%\index{R}{{/}}

\begin{table}
\begin{center}
\caption{Basic arithmetic operations in \R.}
\tabcapsep
\label{tab:arithmetic1}
\begin{tabular}{lc|cc} 
operation  		& operator 	& example input & example output\\ \hline
addition			&\rtext{+}	& \rtext{10 + 2}	& \rtextoutput{12}\\
subtraction		&\rtext{-}	& \rtext{9 - 3} 	& \rtextoutput{6} \\
multiplication	&\rtext{*}	& \rtext{5 * 5} 	& \rtextoutput{25}\\ 
division			&\rtext{/}	& \rtext{10 / 3} & \rtextoutput{3}\\ 
power	& \rtextverb#^#	& \rtext{5} \rtextverb#^# \rtext{2}& \rtextoutput{25} \\
\end{tabular} \tabcapsep
\end{center}
\end{table}


We already know \R\ can do any kind of arithmetic calculation.  Table~\ref{tab:arithmetic1} lists the arithmetic operators that correspond to the basic arithmetic we learned in primary school: addition, subtraction, multiplication and division. As you can see, \R\ uses fairly standard symbols to denote each of the different operations you might want to perform: addition is done using the \rtext{+} operator, subtraction is performed by the \rtext{-} operator, and so on. So if I wanted to find out what 57 times 61 is (and who wouldn't?), I can use \R\ instead of a calculator, like so:
\begin{rblock1}
> @usr{57 * 61}
[1] 3477
\end{rblock1}

Please notice that
\begin{rblock1}
> @usr{1 + 2 * 4}
[1] 9
\end{rblock1}
and 
\begin{rblock1}
> @usr{2 * 4 + 1}
[1] 9
\end{rblock1}
but
\begin{rblock1}
> @usr{(1 + 2) * 4} 
[1] 12
\end{rblock1}
Thus, the \keyterm{order of operations} plays a role. It's actually the same order that you got taught when you were at school: the ``\textsc{bedmas}'' order. That is, first calculate things inside {\bf B}rackets \rtext{()}, then calculate {\bf E}xponents \rtextverb#^#, then {\bf D}ivision \rtext{/} and {\bf M}ultiplication \rtext{*}, then {\bf A}ddition \rtext{+} and {\bf S}ubtraction \rtext{-}. Thus, better write:





\section{Storing a number as a variable~\label{sec:assign}}
%\index{R}{{<-}}
%\index{R}{{=}}

One of the most important things to be able to do in \R\ (or any programming language, for that matter) is to store information in \keyterm{variables} or so called \keyterm{objects}. At a conceptual level you can think of a variable as {\it label} for a certain piece of information, or even several different pieces of information. When doing statistical analysis in \R\ all of your data (the variables you measured in your study) will be stored as variables in \R. Let's look at the very basics for how we create variables and work with them. 

\subsection{The assignment operator \rtext{<-} }

Suppose I'm trying to calculate how much money I'm going to make from this book. I agree, it is an unrealistic example but it will help you to understand \R. 
Let's assume I'm only going to sell 350 copies. To create a variable called \rtext{sales} that assign a \keyterm{value} to my variable \rtext{sales}, we need to use the \keyterm{assignment operator} of \R, which is \rtext{<-} as follows:
\begin{rblock1}
> @usr{sales <- 350}
\end{rblock1}
When you hit enter, \R\ doesn't print out any output. (If you are using Rstudio, and the ``environment'' panel you can see that something happened there, can you?) It just gives you another command prompt. However, behind the scenes \R\ has created a variable called \rtext{sales} and given it a value of \rtext{350}. You can check that this has happened by asking \R\ to print the variable on screen. And the simplest way to do {\it that} is to type the name of the variable and hit enter.
\begin{rblock1}
> @usr{sales}
[1] 350
\end{rblock1}

Okay, so now we know how to assign variables and print out the value(s) of a variable. 

Worth a mentioning is the curious features of \R\ that there are several different ways of making assignments. In addition to the \rtext{<-} operator, we can also use \rtext{->} and \rtext{=}. If you want to use \rtext{->}, you might expect from just looking at the symbol you should write it like this:
\begin{rblock1}
> @usr{350 -> sales}
\end{rblock1}
However, it is common practice to use \rtext{<-} and I recommend only to use this one because it is easier to read in scripts.


\subsection{Doing calculations using variables}

In addition to defining a \rtext{sales} variable that counts the number of copies I'm going to sell, I can also create a variable called \rtext{royalty}, indicating how much money I get per copy. Let's say that my royalties are about \$7 per book:
\begin{rblock1}
> @usr{sales <- 350}
> @usr{royalty <- 7}
\end{rblock1}
The nice thing about variables (in fact, the whole point of having variables) is that we can do anything with a variable that we ought to be able to do with the information that it stores. That is, since \R\ allows me to multiply \rtext{350} by \rtext{7}
\begin{rblock1}
> @usr{350 * 7}
[1] 2450
\end{rblock1}
it also allows me to multiply \rtext{sales} by \rtext{royalty}
\begin{rblock1}
> @usr{sales * royalty}
[1] 2450
\end{rblock1}
As far as \R\ is concerned, the \rtext{sales * royalty} command is the same as the \rtext{350 * 7} command. Not surprisingly, I can assign the output of this calculation to a new variable, which I'll call \rtext{revenue}. And when we do this, the new variable \rtext{revenue} gets the value \rtext{2450}. So let's do that, and then get \R\ to print out the value of \rtext{revenue} so that we can verify that it's done what we asked:
\begin{rblock1}
> @usr{revenue <- sales * royalty}
> @usr{revenue}
[1] 2450
\end{rblock1}
That's fairly straightforward. A slightly more subtle thing we can do is reassign the value of my variable, based on its current value. For instance, suppose that one of my students (no doubt under the influence of psychotropic drugs) loves the book so much that he or she donates me an extra \$550. The simplest way to capture this is by a command like this:
\begin{rblock1}
> @usr{revenue <- revenue + 550}
> @usr{revenue}
[1] 3000
\end{rblock1}
In this calculation, \R\ has taken the old value of \rtext{revenue} (i.e., 2450) and added 550 to that value, producing a value of 3000. This new value is assigned to the \rtext{revenue} variable, overwriting its previous value. In any case, we now know that I'm expecting to make \$3000 off this. 

\subsection{Rules and conventions for naming variables}

Variables can be given almost any name, such as `x', `current\_temperature', or `subject\_id'. However, there are some rules and suggestions you should keep in mind.
Firstly, try to be consistent with the styling of your code (where you put spaces, how you name variable, etc.). In R, two popular style guides are \textit{Hadley Wickham's style guide} (see: \websmall\url{http://adv-r.had.co.nz/Style.html}) and \textit{Google's} style guide (see:  \websmall\url{http://web.stanford.edu/class/cs109l/unrestricted/resources/google-style.html}).
In the examples that we've seen so far, my variable names (\rtext{sales} and \rtext{revenue}) have just been English-language words written using lowercase letters. However, \R\ allows a lot more flexibility when it comes to naming your variables, as the following list of rules illustrates:


\itex{\item Make your names explicit and not too long.
	\item Avoid names starting with a number (`2x' is not valid but `x2' is)
	\item Avoid names of fundamental functions in \R (e.g., `if', `else', `for', see \websmall\url{https://statisticsglobe.com/r-functions-list/} for a complete list. In general, even if it's allowed, it's best to not use other function names (e.g., `c', `T', `mean', `data') as variable names. When in doubt
	check the help to see if the name is already in use. 
	\item Avoid dots (`.') within a variable name as in `my.dataset'. There are many functions
	in \R with dots in their names for historical reasons, but because dots have a special meaning in \R (for methods) and other programming languages, it's best to avoid them. 
	\item Use nouns for object names and verbs for function names
	\item Keep in mind that \textit{\R is case sensitive} (e.g., `genome\_length' is different from `Genome\_length')
}
\begin{itemize}
\item Variable names can only use the upper case alphabetic characters \rtext{A}-\rtext{Z} as well as the lower case characters \rtext{a}-{\rtext{z}}. You can also include numeric characters \rtext{0}-\rtext{9} in the variable name, as well as the period \rtext{.} or underscore \rtextverb#_# character. In other words, you can use \rtextverb#SaL.e_s# as a variable name (though I can't think why you would want to), but you can't use \rtext{Sales?}. 
\item Variable names cannot include spaces: therefore \rtext{my sales} is not a valid name, but \rtext{my.sales} is.
\item Variable names are case sensitive: that is, \rtext{Sales} and \rtext{sales} are {\it different} variable names.
\item Variable names must start with a letter or a period. You can't use something like \rtextverb#_sales# or \rtext{1sales} as a variable name. You can use \rtext{.sales} as a variable name if you want, but it's not usually a good idea. By convention, variables starting with a \rtext{.} are used for special purposes, so you should avoid doing so. 
\item Variable names cannot be one of the reserved keywords. These are special names that \R\ needs to keep ``safe'' from us mere users, so you can't use them as the names of variables. The keywords are: \rtext{if}, \rtext{else}, \rtext{repeat}, \rtext{while}, \rtext{function}, \rtext{for}, \rtext{in}, \rtext{next}, \rtext{break}, \rtext{TRUE}, \rtext{FALSE}, \rtext{NULL}, \rtext{Inf}, \rtext{NaN}, \rtext{NA}, \rtextverb#NA_integer_#, \rtextverb#NA_real_#, \rtextverb#NA_complex_#, and finally,  \rtextverb#NA_character_#. Don't feel especially obliged to memorise these: if you make a mistake and try to use one of the keywords as a variable name, \R\ will complain about it like the whiny little automaton it is.
\end{itemize}

\noindent
In addition to those rules that \R\ enforces, there are some informal conventions that people tend to follow when naming variables. One of them you've already seen: i.e., don't use variables that start with a period. But there are several others. You aren't obliged to follow these conventions, and there are many situations in which it's advisable to ignore them, but it's generally a good idea to follow them when you can:

\begin{itemize}
\item Use informative variable names. As a general rule, using meaningful names like \rtext{sales} and \rtext{revenue} is preferred over arbitrary ones like \rtext{variable1} and \rtext{variable2}. Otherwise it's very hard to remember what the contents of different variables are, and it becomes hard to understand what your commands actually do. 
\item Use short variable names. Typing is a pain and no-one likes doing it. So we much prefer to use a name like \rtext{sales} over a name like \rtext{sales.for.this.book.that.you.are.reading}. Obviously there's a bit of a tension between using informative names (which tend to be long) and using short names (which tend to be meaningless), so use a bit of common sense when trading off these two conventions.
\item Use one of the conventional naming styles for multi-word variable names. Suppose I want to name a variable that stores ``my new salary''. Obviously I can't include spaces in the variable name, so how should I do this? There are three different conventions that you sometimes see \R\ users employing. Firstly, you can separate the words using periods, which would give you \rtextverb#my.new.salary# as the variable name. Alternatively, you could separate words using underscores, as in \rtextverb#my_new_salary#. Finally, you could use capital letters at the beginning of each word (except the first one), which gives you \rtext{myNewSalary} as the variable name. I don't think there's any strong reason to prefer one over the other, but it's important to be consistent.
\end{itemize}




\section{Using functions to do calculations\label{sec:usingfunctions}}

As we've seen, you can do quite a lot of calculations just by using arithmetic operators such as +, -, * etc. However, to do more advanced calculations, you're going to need to start using \keyterm{functions}.
For example, if you like to calculate
$$
\sqrt{25} = 5
$$
which is sometimes is written like this
$
25^{0.5} = 5.
$
you can use the operator \rtextverb#^#, just like we did earlier:
\begin{rblock1}
> @usr{225 ^ 0.5}
[1] 15
\end{rblock1}
However, there's a second way that we can do this, since \R\ also provides a \keyterm{square root function}, \rtext{sqrt()}:
%\index{R}{sqrt}
\begin{rblock1}
> @usr{sqrt( 225 )}
[1] 15
\end{rblock1}

When we use a function to do something, we generally refer to this as \keyterm{calling} the function, and the values that we type into the function (there can be more than one) are referred to as the \keyterm{arguments} of that function. 

\R\ offers many (more helpful) functions such as the \keyterm{absolute value function} which converts negative numbers to positive numbers, and leaves positive numbers alone. Mathematically, the absolute value of $x$ is written $|x|$ or sometimes $\mbox{abs}(x)$. Calculating absolute values in \R\ is done with the \rtext{abs()} function:
\begin{rblock1} 
> @usr{abs( -13 )}
[1] 13
\end{rblock1} 


It's worth noting that -- in the same way that \R\ allows us to put multiple operations together into a longer command, it also lets us put functions together and even combine functions with operators. For example:
\begin{rblock1}
> @usr{sqrt( 1 + abs(-8) )}
[1] 3
\end{rblock1}
When \R\ executes this command, starts out by calculating the value of \rtext{abs(-8)}, which produces an intermediate value of \rtext{8}. Having done so, the command simplifies to \rtext{sqrt( 1 + 8 )}. To solve the square root  it first needs to add \rtext{1 + 8} to get \rtext{9}, at which point it evaluates \rtext{sqrt(9)}, and so it finally outputs a value of \rtextoutput{3}.



\subsection{Function arguments, their names and their defaults~\label{sec:functionarguments}}

There's two more important things that you need to understand about how functions work in \R, and that's the use of ``named'' arguments, and ``default values'' for arguments. To understand what these two concepts are all about, I'll introduce another function. The \rtext{round()} function can be used to round some value to the nearest whole number. For example, I could type this:
\begin{rblock1}
> @usr{round( 3.1415 )}
[1] 3
\end{rblock1}
However, suppose I only wanted to round it to two decimal places: that is, I want to get \rtextoutput{3.14} as the output. The \rtext{round()} function supports this, by allowing you to input a second argument to the function that specifies the number of decimal places that you want to round the number to. In other words, I could do this: 
\begin{rblock1}
> @usr{round( 3.14165, 2 )}
[1] 3.14
\end{rblock1}
What's happening here is that I've specified {\it two} arguments: the first argument is the number that needs to be rounded (i.e., \rtext{3.1415}), the second argument is the number of decimal places that it should be rounded to (i.e., \rtext{2}), and the two arguments are separated by a comma. In this simple example, it's quite easy to remember which one argument comes first and which one comes second, but for more complicated functions this is not easy. Fortunately, most \R\ functions make use of \keyterm{argument names}. For the \rtext{round()} function, for example the number that needs to be rounded is specified using the \rtext{x} argument, and the number of decimal points that you want it rounded to is specified using the \rtext{digits} argument. Because we have these names available to us, we can specify the arguments to the function by name. We do so like this:
\begin{rblock1}
> @usr{round( x = 3.1415, digits = 2 )}
[1] 3.14
\end{rblock1}
Notice that this is kind of similar in spirit to variable assignment (Section~\ref{sec:assign}), except that I used \rtext{=} here, rather than \rtext{<-}. In both cases we're specifying specific values to be associated with a label. However, there are some differences between what I was doing earlier on when creating variables, and what I'm doing here when specifying arguments, and so as a consequence it's important that you use \rtext{=} in this context.


As you can see, specifying the arguments by name involves a lot more typing, but it's also a lot easier to read. Because of this, the commands in this book will usually specify arguments by name,
 since that makes it clearer to you what I'm doing. However, one important thing to note is that when specifying the arguments using their names, it doesn't matter what order you type them in. But if you don't use the argument names, then you have to input the arguments in the correct order. In other words, these three commands all produce the same output...
\begin{rblock1}
> @usr{round( 3.14165, 2 )}
> @usr{round( x = 3.1415, digits = 2 )}
> @usr{round( digits = 2, x = 3.1415 )}
\end{rblock1}
but this one does not...
\begin{rblock1}
> @usr{round( 2, 3.14165 )}
\end{rblock1}
How do you find out what the correct order is? There's a few different ways, but the easiest one is to look at the help documentation for the function (see Section~\ref{sec:help}). However, if you're ever unsure, it's probably best to actually type in the argument name.

%\subsection{Default values~\label{sec:defaults}}

Okay, so that's the first thing I said you'd need to know: argument names. The second thing you need to know about is default values. Notice that the first time I called the \rtext{round()} function I didn't actually specify the \rtext{digits} argument at all, and yet \R\ somehow knew that this meant it should round to the nearest whole number. How did that happen? The answer is that the \rtext{digits} argument has a \keyterm{default value} of \rtext{0}, meaning that if you decide not to specify a value for \rtext{digits} then \R\ will act as if you had typed \rtext{digits = 0}. This is quite handy: the vast majority of the time when you want to round a number you want to round it to the nearest whole number, and it would be pretty annoying to have to specify the \rtext{digits} argument every single time. On the other hand, sometimes you actually do want to round to something other than the nearest whole number, and it would be even more annoying if \R\ didn't allow this! Thus, by having \rtext{digits = 0} as the default value, we get the best of both worlds.


\exex{Calculate}{Write the code to\dots 
	\abcx{
		\item \dots\textit{\textbf{calculate and store}} the result of the following calculation: $$	\sqrt{8}\cdot \left(\frac{3}{4}+7^{-2}\right)\cdot 9:2$$
		\item \dots round the result up (three digits) and store the result in an object entitled \rtext{result\_rounded}
	}
}


\section{Letting \Rstudio help you with your commands\label{sec:Rstudio1}}

At this stage you know how to type in basic commands, including how to use \R\ functions. And it's probably beginning to dawn on you that there are a {\it lot} of \R\ functions, all of which have their own arguments. You're probably also worried that you're going to have to remember all of them! Thankfully, it's not that bad. In fact, very few data analysts bother to try to remember all the commands. What they really do is use tricks to make their lives easier. The first (and arguably most important one) is to use the internet. If you don't know how a particular \R\ function works: Google it (or use \url{www.rseek.org})!  Second, you can look up the \R\ help documentation. Third, you can use the \textit{autocomplete service} of \Rstudio. Fourth, you can use the \textit{History} privided by \Rstudio.

\boxb{\textbf{Cheatsheets:} Check out these \textbf{cheatsheets}: \websmall\url{https://rstudio.com/resources/cheatsheets/}}

\subsection{Autocomplete using ``tab''}

The first thing I  want to call your attention to is the {\it autocomplete} ability in \Rstudio.
Let's stick to our example above and assume that what you want to do is to round a number. This time around, start typing the name of the function that you want, and then hit the ``tab'' key. \Rstudio will then display a little window like the one shown in Figure~\ref{fig:Rstudiotab}. In this figure, I've typed the letters \rtext{ro} at the command line, and then hit tab. The window has two panels. On the left, there's a list of variables and functions that start with the letters that I've typed shown in black text, and some grey text that tells you where that variable/function is stored. Ignore the grey text for now: it won't make much sense to you until we've talked about packages in Section~\ref{sec:packageinstall}. In Figure~\ref{fig:Rstudiotab} you can see that there's quite a few things that start with the letters \rtext{ro}: there's something called \rtext{rock}, something called \rtext{round}, something called \rtext{round.Date} and so on. The one we want is \rtext{round}, but if you're typing this yourself you'll notice that when you hit the tab key the window pops up with the top entry (i.e., \rtext{rock}) highlighted. You can use the up and down arrow keys to select the one that you want. Or, if none of the options look right to you, you can hit the escape key (``esc'') or the left arrow key to make the window go away. 

In our case, the thing we want is the \rtext{round} option, so we'll select that. When you do this, you'll see that the panel on the right changes. Previously, it had been telling us something about the \rtext{rock} data set (i.e., ``Measurements on 48 rock samples...'') that is distributed as part of \R. But when we select \rtext{round}, it displays information about the \rtext{round()} function, exactly as it is shown in Figure~\ref{fig:Rstudiotab}. This display is really handy. The very first thing it says is \texttt{round(x, digits = 0)}: what this is telling you is that the \rtext{round()} function has two arguments. The first argument is called \rtext{x}, and it doesn't have a default value. The second argument is \rtext{digits}, and it has a default value of 0. In a lot of situations, that's all the information you need. But \Rstudio goes a bit further, and provides some additional information about the function underneath. Sometimes that additional information is very helpful, sometimes it's not: \Rstudio pulls that text from the \R\ help documentation, and my experience is that the helpfulness of that documentation varies wildly. Anyway, if you've decided that \rtext{round()} is the function that you want to use, you can hit the right arrow or the enter key, and \Rstudio will finish typing the rest of the function name for you. 

\begin{figure}[t]
\begin{center}
		\includegraphics[width=.6\linewidth]{$HOME/Dropbox/hsf/pic/Rstudio/Rstudio_tab}
\caption{Start typing the name of a function or a variable, and hit the ``tab'' key. \Rstudio brings up a little dialog box like this one that lets you select the one you want, and even prints out a little information about it.}
\label{fig:Rstudiotab}
\end{center}
\end{figure}

The \Rstudio autocomplete tool works slightly differently if you've already got the name of the function typed and you're now trying to type the arguments. For instance, suppose I've typed \rtext{round(} into the console, and {\it then} I hit tab. \Rstudio is smart enough to recognize that I already know the name of the function that I want, because I've already typed it! Instead, it figures that what I'm interested in is the {\it arguments} to that function. So that's what pops up in the little window. You can see this in Figure~\ref{fig:Rstudiotab2}. Again, the window has two panels, and you can interact with this window in exactly the same way that you did with the window shown in Figure~\ref{fig:Rstudiotab}. On the left hand panel, you can see a list of the argument names. On the right hand side, it displays some information about what the selected argument does. 


\begin{figure}[t]
\begin{center}
		\includegraphics[width=.6\linewidth]{$HOME/Dropbox/hsf/pic/Rstudio/Rstudio_tab2}
\caption{If you've typed the name of a function already along with the left parenthesis and then hit the ``tab'' key, \Rstudio brings up a different window to the one shown in Figure~\protect\ref{fig:Rstudiotab}. This one lists all the arguments to the function on the left, and information about each argument on the right.}
\label{fig:Rstudiotab2}
\end{center}
\end{figure}


\subsection{Browsing your command history}

One thing that \R\ does automatically is keep track of your ``command history''. That is, it remembers all the commands that you've previously typed. You can access this history in a few different ways. The simplest way is to use the up and down arrow keys. If you hit the up key, the \R\ console will show you the most recent command that you've typed. Hit it again, and it will show you the command before that. If you want the text on the screen to go away, hit escape. Incidentally, that always works: if you've started typing a command and you want to clear it and start again, hit escape. Using the up and down keys can be really handy if you've typed a long command that had one typo in it. Rather than having to type it all again from scratch, you can use the up key to bring up the command and fix it. 

The second way to get access to your command history is to look at the history panel in \Rstudio. On the upper right hand side of the \Rstudio window you'll see a tab labelled ``History''. Click on that, and you'll see a list of all your recent commands displayed in that panel: it should look something like Figure~\ref{fig:Rstudiohistory}. If you double click on one of the commands, it will be copied to the \R\ console. (You can achieve the same result by selecting the command you want with the mouse and then clicking the ``To Console'' button). 

Another method is to start typing some text and then hit the Control key and the up arrow together (on Windows or Linux) or the Command key and the up arrow together (on a Mac). This will bring up a window showing all your recent commands that started with the same text as what you've currently typed. That can come in quite handy sometimes.

\begin{figure}[t]
\begin{center}
		\includegraphics[width=.5\linewidth]{$HOME/Dropbox/hsf/pic/Rstudio/historyTab}
\caption{The history panel is located in the top right hand side of the Rstudio window. Click on the word ``History'' and it displays this panel.  }
\label{fig:Rstudiohistory}
\end{center}
\end{figure}



\section{Storing many numbers as a vector~\label{sec:vectors}}

When I introduced variables in Section~\ref{sec:assign}, I showed you how we can use variables to store a single number. In this section, we'll extend this idea and look at how to store multiple numbers within the one variable. In \R\, the name for a variable that can store multiple values is a \keyterm{vector}. 

\subsection{Creating a vector}
%\index{R}{{c()}}

Let's get bach to my silly ``get rich by textbook writing'' example. Suppose the textbook company sends me sales data on a monthly basis. Since my class start in late February, we might expect most of the sales to occur towards the start of the year. Let's suppose that I have 100 sales in February, 200 sales in March and 50 sales in April, and no other sales for the rest of the year. What I would like to do is have a variable -- let's call it \rtext{sales.by.month} -- that stores all this sales data. The first number stored should be \rtext{0} since I had no sales in January, the second should be \rtext{100}, and so on. The simplest way to do this in \R\ is to use the \keyterm{combine} function, \rtext{c()}. To do so, all we have to do is type all the numbers you want to store in a comma separated list, like this:
\begin{rblock1}
> @usr{sales.by.month <- c(0, 100, 200, 50, 0, 0, 0, 0, 0, 0, 0, 0)}
> @usr{sales.by.month}
 [1]   0 100 200  50   0   0   0   0   0   0   0   0
\end{rblock1}
To use the correct terminology here, we have a single variable here called \rtext{sales.by.month}: this variable is a vector that consists of 12 \keyterm{elements}. 
Notice that I didn't specify any argument names here. The \rtextsmall{c()} function is one of those cases where we don't use names. We just type all the numbers, and \R\ just dumps them all in a single variable.





\subsection{Showing the output}

Now that we've learned how to put information into a vector, the next  thing to understand is how to pull that information back out again. However, before I do so it's worth taking a slight detour. If you've been following along, typing all the commands into \R\ yourself, it's possible that the output that you saw when we printed out the \rtext{sales.by.month} vector was slightly different to what I showed above. This would have happened if the window (or the Rstudio panel) that contains the \R\ console is really, really narrow. If that were the case, you might have seen output that looks something like this:
\begin{rblock1}
> @usr{sales.by.month}
 [1]   0 100 200  50   0   0   0   0
 [9]   0   0   0   0
\end{rblock1}
Because there wasn't much room on the screen, \R\ has printed out the results over two lines. But that's not the important thing to notice. The important point is that the first line has a \rtextoutput{[1]} in front of it, whereas the second line starts with \rtextoutput{[9]}. It's pretty clear what's happening here. For the first row, \R\ has printed out the 1st element through to the 8th element, so it starts that row with a \rtextoutput{[1]}. For the second row, \R\ has printed out the 9th element of the vector through to the 12th one, and so it begins that row with a \rtextoutput{[9]} so that you can tell where it's up to at a glance. It might seem a bit odd to you that \R\ does this, but in some ways it's a kindness, especially when dealing with larger data sets!


\subsection{Getting information out of vectors\label{sec:vectorsubset}}

To get back to the main story, let's consider the problem of how to get information out of a vector. At this point, you might have a sneaking suspicion that the answer has something to do with the \rtextoutput{[1]} and \rtextoutput{[9]} things that \R\ has been printing out. And of course you are correct. Suppose I want to pull out the February sales data only. February is the second month of the year, so let's try this:
\begin{rblock1}
> @usr{sales.by.month[2]}
[1] 100
\end{rblock1}
Yep, that's the February sales all right. But there's a subtle detail to be aware of here: notice that \R\ outputs \rtextoutput{[1] 100}, {\it not} \rtextoutput{[2] 100}. This is because \R\ is being extremely literal. When we typed in \rtext{sales.by.month[2]}, we asked \R\ to find exactly {\it one} thing, and that one thing happens to be the second element of our \rtext{sales.by.month} vector. So, when it outputs \rtextoutput{[1] 100} what \R\ is saying is that the first number {\it that we just asked for} is \rtextoutput{100}. This behaviour makes more sense when you realise that we can use this trick to create new variables. For example, I could create a \rtext{february.sales} variable like this:
\begin{rblock1}
> @usr{february.sales <- sales.by.month[2]}
> @usr{february.sales}
[1] 100
\end{rblock1}
Obviously, the new variable \rtext{february.sales} should only have one element and so when I print it out this new variable, the \R\ output begins with a \rtextoutput{[1]} because \rtext{100} is the value of the first (and only) element of \rtext{february.sales}. The fact that this also happens to be the value of the second element of \rtext{sales.by.month} is irrelevant. We'll pick this topic up again shortly (Section~\ref{sec:indexing}). 

\subsection{Altering the elements of a vector}

Sometimes you'll want to change the values stored in a vector. Imagine my surprise when the publisher rings me up to tell me that the sales data for May are wrong. There were actually an additional 25 books sold in May, but there was an error or something so they hadn't told me about it. How can I fix my \rtext{sales.by.month} variable? One possibility would be to assign the whole vector again from the beginning, using \rtext{c()}. But that's a lot of typing. Also, it's a little wasteful: why should \R\ have to redefine the sales figures for all 12 months, when only the 5th one is wrong? Fortunately, we can tell \R\ to change only the 5th element, using this trick:
\begin{rblock1}
> @usr{sales.by.month[5] <- 25}
> @usr{sales.by.month}
 [1]   0 100 200  50  25   0   0   0   0   0   0   0
\end{rblock1}

Another way to edit variables is to use the \rtext{fix()} function. I won't discuss them in detail right now, but you can check them out on your own. 


\subsection{Useful things to know about vectors~\label{sec:veclength}}
%\index{R}{{length()}}

Before moving on, I want to mention a couple of other things about vectors. Firstly, you often find yourself wanting to know how many elements there are in a vector (usually because you've forgotten). You can use the \rtext{length()} function to do this. It's quite straightforward:
\begin{rblock1}
> @usr{length( x = sales.by.month )}
[1] 12
\end{rblock1}

\noindent
Secondly, you often want to alter all of the elements of a vector at once. For instance, suppose I wanted to figure out how much money I made in each month. Since I'm earning an exciting \$7 per book, what I want to do is multiply each element in the \rtext{sales.by.month} vector by \rtext{7}. \R\ makes this pretty easy, as the following example shows:
\begin{rblock1}
> @usr{sales.by.month * 7}
 [1]    0  700 1400  350    0    0    0    0    0    0    0    0
\end{rblock1}
In other words, when you multiply a vector by a single number, all elements in the vector get multiplied. The same is true for addition, subtraction, division and taking powers. So that's neat. On the other hand, suppose I wanted to know how much money I was making per day, rather than per month. Since not every month has the same number of days, I need to do something slightly different. Firstly, I'll create two new vectors:
\begin{rblock1}
> @usr{days.per.month <- c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)}
> @usr{profit <- sales.by.month * 7}
\end{rblock1}
Obviously, the \rtext{profit} variable is the same one we created earlier, and the \rtext{days.per.month} variable is pretty straightforward. What I want to do is divide every element of \rtext{profit} by the {\it corresponding} element of \rtext{days.per.month}. Again, \R\ makes this pretty easy:
\begin{rblock1}
> @usr{profit / days.per.month}
 [1]  0.00000 25.00000 45.16129 11.66667  0.00000  0.00000  0.00000  0.00000  0.00000
[10]  0.00000  0.00000  0.00000
\end{rblock1}
I still don't like all those zeros, but that's not what matters here. Notice that the second element of the output is 25, because \R\ has divided the second element of \rtext{profit} (i.e. 700) by the second element of \rtext{days.per.month} (i.e. 28). Similarly, the third element of the output is equal to 1400 divided by 31, and so on. We'll talk more about calculations involving vectors later on, but that's enough detail for now.

\section{Storing text data\label{sec:text}}

A lot of the time your data will be numeric in nature, but not always. Sometimes your data really needs to be described using text, not using numbers. To address this, we need to consider the situation where our variables store text. To create a variable that stores the word ``hello'', we can type this:
\begin{rblock1}
> @usr{greeting <- "hello"}
> @usr{greeting}
[1] "hello"
\end{rblock1}
When interpreting this, it's important to recognise that the quote marks here {\it aren't} part of the string itself. They're just something that we use to make sure that \R\ knows to treat the characters that they enclose as a piece of text data, known as a \keyterm{character string}. In other words, \R\ treats \rtext{"hello"} as a string containing the word ``hello''; but if I had typed \rtext{hello} instead, \R\ would go looking for a variable by that name! You can also use \rtext{'hello'} to specify a character string.

Okay, so that's how we store the text. Next, it's important to recognise that when we do this, \R\ stores the entire word \rtext{"hello"} as a {\it single} element: our \rtext{greeting} variable is \underline{not} a vector of five different letters. Rather, it has only the one element, and that element corresponds to the entire character string \rtext{"hello"}. To illustrate this, if I actually ask \R\ to find the first element of \rtext{greeting}, it prints the whole string:
\begin{rblock1}
> @usr{greeting[1]}
[1] "hello"
\end{rblock1}
Of course, there's no reason why I can't create a vector of character strings. For instance, if we were to continue with the example of my attempts to look at the monthly sales data for my book, one variable I might want would include the names of all 12 \rtext{months}. To do so, I could type in a command like this
\begin{rblock1}
> @usr{months <- c("January", "February", "March", "April", "May", "June",}
+ @usr{            "July", "August", "September", "October", "November", "December")}
> @usr{months}
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 
\end{rblock1}
This is a \keyterm{character vector} containing 12 elements, each of which is the name of a month. So if I wanted \R\ to tell me the name of the fourth month, all I would do is this:
\begin{rblock1}
> @usr{months[4]}
[1] "April"
\end{rblock1}


\subsection*{Working with text~\label{sec:simpletext}}

Working with text data is somewhat more complicated than working with numeric data. For purposes of the current chapter we only need this bare bones sketch. The only other thing I want to do before moving on is show you an example of a function that can be applied to text data. So far, most of the functions that we have seen (i.e., \rtext{sqrt()}, \rtext{abs()} and \rtext{round()}) only make sense when applied to numeric data (e.g., you can't calculate the square root of ``hello''), and we've seen one function that can be applied to pretty much any variable or vector (i.e., \rtext{length()}). So it might be nice to see an example of a function that can be applied to text. 

The function I'm going to introduce you to is called \rtext{nchar()}, and what it does is count the number of individual characters that make up a string. Recall earlier that when we tried to calculate the \rtext{length()} of our \rtext{greeting} variable it returned a value of \rtext{1}: the \rtext{greeting} variable contains only the one string, which happens to be \rtext{"hello"}. But what if I want to know how many letters there are in the word? Sure, I could {\it count} them, but that's boring, and more to the point it's a terrible strategy if what I wanted to know was the number of letters in {\it War and Peace}. That's where the \rtext{nchar()} function is helpful:
\begin{rblock1}
> @usr{nchar( x = greeting )}
[1] 5
\end{rblock1}
That makes sense, since there are in fact 5 letters in the string \rtext{"hello"}. Better yet, you can apply \rtext{nchar()} to whole vectors. So, for instance, if I want \R\ to tell me how many letters there are in the names of each of the 12 months, I can do this:
\begin{rblock1}
> @usr{nchar( x = months )}
 [1] 7 8 5 5 3 4 4 6 9 7 8 8
\end{rblock1}
So that's nice to know. The \rtext{nchar()} function can do a bit more than this, and there's a lot of other functions that you can do to extract more information from text or do all sorts of fancy things. However, the goal here is not to teach any of that! The goal right now is just to see an example of a function that actually does work when applied to text. 


\section{Storing ``true or false'' data\label{sec:logicals}}
%\index{R}{{TRUE}}
%\index{R}{{FALSE}}

Time to move onto a third kind of data. A key concept in that a lot of \R\ relies on is the idea of a \keyterm{logical value}. A logical value is an assertion about whether something is true or false. This is implemented in \R\ in a pretty straightforward way. There are two logical values, namely \rtext{TRUE} and \rtext{FALSE}. Despite the simplicity, a logical values are very useful things. Let's see how they work.

\subsection{Assessing mathematical truths}
%\index{R}{{==}}
%\index{ideas}{logical operations}

In George Orwell's classic book {\it 1984}, one of the slogans used by the totalitarian Party was ``two plus two equals five'', the idea being that the political domination of human freedom becomes complete when it is possible to subvert even the most basic of truths. It's a terrifying thought, especially when the protagonist Winston Smith finally breaks down under torture and agrees to the proposition. \R has rather firm opinions on the topic of what is and isn't true, at least as regards basic mathematics. If I ask it to calculate \rtext{2 + 2}, it always gives the same answer, and it's not 5:
\begin{rblock1}
> @usr{2 + 2}
[1] 4
\end{rblock1}
Of course, so far \R\ is just doing the calculations. I haven't asked it to explicitly assert that $2+2 = 4$ is a true statement. If I want \R\ to make an explicit judgement, I can use a command like this: 
\begin{rblock1}
> @usr{2 + 2 == 4}
[1] TRUE
\end{rblock1}
What I've done here is use the \keyterm{equality operator}, \rtext{==}, to force \R\ to make a ``true or false'' judgment. Note that this is a very different operator to the assignment operator \rtextsmall{=} that I talked about in Section~\ref{sec:assign}. A common typo that people make when trying to write logical commands in \R\ (or other languages, since the ``\rtextsmall{=} versus \rtextsmall{==}'' distinction is important in most programming languages) is to accidentally type \rtextsmall{=} when you really mean \rtextsmall{==}.

Okay, let's see what \R\ thinks of the Party slogan:
\begin{rblock1}
> @usr{2+2 == 5}
[1] FALSE
\end{rblock1}
What a relief! Or something like that. Anyway, it's worth having a look at what happens if I try to {\it force} \R\ to believe that two plus two is five by making an assignment statement like  \rtext{2 + 2 = 5} or \rtext{2 + 2 <- 5}. When I do this, here's what happens:
\begin{rblock1}
> @usr{2 + 2 = 5}
Error in 2 + 2 = 5 : target of assignment expands to non-language object
\end{rblock1}
\R\ doesn't like this very much. It recognises that \rtext{2 + 2} is {\it not} a variable (that's what the ``non-language object'' part is saying), and it won't let you try to ``reassign'' it. While \R\ is pretty flexible, and actually does let you do some quite remarkable things to redefine parts of \R\ itself, there are just some basic, primitive truths that it refuses to give up. It won't change the laws of addition, and it won't change the definition of the number \rtext{2}. 

That's probably for the best.

\subsection{Logical operations}
%\index{R}{{<}}
%\index{R}{{<=}}
%\index{R}{{>=}}
%\index{R}{{!=}}

So now we've seen logical operations at work, but so far we've only seen the simplest possible example. You probably won't be surprised to discover that we can combine logical operations with other operations and functions in a more complicated way, like this:
\begin{rblock1}
> @usr{3*3 + 4*4 == 5*5}
[1] TRUE
\end{rblock1} 
or this
\begin{rblock1}
> @usr{sqrt( 25 ) == 5}
[1] TRUE
\end{rblock1}
Not only that, but as Table~\ref{tab:logicals} illustrates, there are several other logical operators that you can use, corresponding to some basic mathematical concepts. Hopefully these are all pretty self-explanatory: for example, the \keyterm{less than} operator \rtext{<} checks to see if the number on the left is less than the number on the right. If it's less, then \R\ returns an answer of \rtextoutput{TRUE}:
\begin{rblock1}
> @usr{99 < 100}
[1] TRUE
\end{rblock1}
but if the two numbers are equal, or if the one on the right is larger, then \R\ returns an answer of \rtextoutput{FALSE}, as the following two examples illustrate:
\begin{rblock1}
> @usr{100 < 100}
[1] FALSE
> @usr{100 < 99}
[1] FALSE
\end{rblock1}
In contrast, the \keyterm{less than or equal to} operator \rtextverb#<=# will do exactly what it says. It returns a value of \rtextoutput{TRUE} if the number of the left hand side is less than or equal to the number on the right hand side. So if we repeat the previous two examples using \rtextverb#<=#, here's what we get: 
\begin{rblock1}
> @usr{100 <= 100}
[1] TRUE
> @usr{100 <= 99}
[1] FALSE
\end{rblock1}
And at this point I hope it's pretty obvious what the \keyterm{greater than} operator \rtext{>} and the \keyterm{greater than or equal to} operator \rtextverb#>=# do! Next on the list of logical operators is the \keyterm{not equal to} operator \rtextverb#!=# which -- as with all the others -- does what it says it does. It returns a value of \rtext{TRUE} when things on either side are not identical to each other. Therefore, since $2+2$ isn't equal to $5$, we get:
\begin{rblock1}
> @usr{2 + 2 != 5}
[1] TRUE
\end{rblock1}


\begin{table}
\caption{Some logical operators. Technically I should call these ``binary relational operators''.} \tabcapsep
\label{tab:logicals}\label{tab:logicals2}
\begin{center}
\begin{tabular}{lc|cc}
operation  				& operator 	& example input 	& answer \\ \hline
less than  				&\rtextverb#<# 	& \rtextverb#2 < 3# 	& \rtextoutput{TRUE} \\
less than or equal to	&\rtextverb#<=#	& \rtextverb#2 <= 2#	& \rtextoutput{TRUE} \\
greater than				&\rtextverb#>#	& \rtextverb#2 > 3# 	& \rtextoutput{FALSE}\\
greater than or equal to	&\rtextverb#>=#	& \rtextverb#2 >= 2# & \rtextoutput{TRUE} \\ 
equal to			&\rtextverb#==#	& \rtextverb#2 == 3# & \rtextoutput{FALSE}\\
not equal to				&\rtextverb#!=#	& \rtextverb#2 != 3# & \rtextoutput{TRUE} \\\hline\hline
not 						&\rtextverb#!#	& \rtextverb#!(1==1)# & \rtextoutput{FALSE} \\ 
or 						&\rtextverb#|#	& \rtextverb#(1==1) | (2==3)# & \rtextoutput{TRUE} \\
and 						&\rtextverb#&# &\rtextverb#(1==1) & (2==3)# & \rtextoutput{FALSE} \\ 
\end{tabular}
\end{center}
\end{table}

We're not quite done yet. There are three more logical operations that are worth knowing about, listed in Table~\ref{tab:logicals2}. These are the \keyterm{not} operator \rtextverb#!#, the \keyterm{and} operator \rtextverb#&#, and the \keyterm{or} operator \rtextverb#|#. Like the other logical operators, their behaviour is more or less exactly what you'd expect given their names. For instance, if I ask you to assess the claim that ``either $2+2 = 4$ {\it or} $2+2 = 5$'' you'd say that it's true. Since it's an ``either-or'' statement, all we need is for one of the two parts to be true. That's what the \rtext{|} operator does:
\begin{rblock1}
> @usr{(2+2 == 4) | (2+2 == 5)}
[1] TRUE
\end{rblock1}
On the other hand, if I ask you to assess the claim that ``both $2+2 = 4$ {\it and} $2+2 = 5$'' you'd say that it's false. Since this is an {\it and} statement we need both parts to be true. And that's what the \rtextverb#&# operator does:
\begin{rblock1}
> @usr{(2+2 == 4) & (2+2 == 5)}
[1] FALSE
\end{rblock1}
Finally, there's the {\it not} operator, which is simple but annoying to describe in English. If I ask you to assess my claim that ``it is not true that $2+2 = 5$'' then you would say that my claim is true; because my claim is that ``$2+2 = 5$ is false''. And I'm right. If we write this as an \R\ command we get this:  
\begin{rblock1}
> @usr{! (2+2 == 5)}
[1] TRUE
\end{rblock1}
In other words, since \rtext{2+2 == 5} is a \rtext{FALSE} statement, it must be the case that \rtext{!(2+2 == 5)} is a \rtext{TRUE} one. Essentially, what we've really done is claim that ``not false'' is the same thing as ``true''. Obviously, this isn't really quite right in real life. But \R\ lives in a much more black or white world: for \R\ everything is either true or false. No shades of gray are allowed. We can actually see this much more explicitly, like this:
\begin{rblock1}
> @usr{! FALSE}
[1] TRUE
\end{rblock1}
Of course, in our $2+2 = 5$ example, we didn't really need to use ``not'' \rtext{!} and ``equals to'' \rtext{==} as two separate operators. We could have just used the ``not equals to'' operator \rtext{!=} like this:
\begin{rblock1}
> @usr{2+2 != 5}
[1] TRUE
\end{rblock1}
But there are many situations where you really do need to use the \rtext{!} operator. 
%\FOOTNOTE{A note for those of you who have taken a computer science class: yes, \R\ does have a function for exclusive-or, namely \rtextsmall{xor()}. Also worth noting is the fact that \R\ makes the distinction between element-wise operators \rtextsmall{\&} and \rtextsmall{|} and operators that look only at the first element of the vector, namely \rtextsmall{\&\&} and \rtextsmall{||}. To see the distinction, compare the behaviour of a command like \rtextsmall{c(FALSE,TRUE) \& c(TRUE,TRUE)} to the behaviour of something like \rtextsmall{c(FALSE,TRUE) \&\& c(TRUE,TRUE)}. If this doesn't mean anything to you, ignore this footnote entirely. It's not important for the content of this book.}
 

%FINISH THIS, AND DON'T FORGET XOR



\subsection{Storing and using logical data}

%\index{R}{{T}}
%\index{R}{{F}}

Up to this point, I've introduced {\it numeric data} (in Sections~\ref{sec:assign} and~\ref{sec:vectors}) and {\it character data} (in Section~\ref{sec:text}). So you might not be surprised to discover that these \rtext{TRUE} and \rtext{FALSE} values that \R\ has been producing are actually a third kind of data, called {\it logical data}. That is, when I asked \R\ if \rtext{2 + 2 == 5} and it said \rtextoutput{[1] FALSE} in reply, it was actually producing information that we can store in variables. For instance, I could create a variable called \rtext{is.the.Party.correct}, which would store \R's opinion:
\begin{rblock1}
> @usr{is.the.Party.correct <- 2 + 2 == 5}
> @usr{is.the.Party.correct}
[1] FALSE
\end{rblock1}
Alternatively, you can assign the value directly, by typing \rtext{TRUE} or \rtext{FALSE} in your command. Like this:
\begin{rblock1}
> @usr{is.the.Party.correct <- FALSE}
> @usr{is.the.Party.correct}
[1] FALSE
\end{rblock1}
Better yet, because it's kind of tedious to type \rtext{TRUE} or \rtext{FALSE} over and over again, \R\ provides you with a shortcut: you can use \rtext{T} and \rtext{F} instead (but it's case sensitive: \rtext{t} and \rtext{f} won't work). 
Warning! \rtextsmall{TRUE} and \rtextsmall{FALSE} are reserved keywords in \R, so you can trust that they always mean what they say they do. Unfortunately, the shortcut versions \rtextsmall{T} and \rtextsmall{F} do not have this property. It's even possible to create variables that set up the reverse meanings, by typing commands like \rtextsmall{T <- FALSE} and \rtextsmall{F <- TRUE}. This is kind of insane, and something that is generally thought to be a design flaw in \R. Anyway, the long and short of it is that it's safer to use \rtextsmall{TRUE} and \rtextsmall{FALSE}.
So this works:
\begin{rblock1}
> @usr{is.the.Party.correct <- F}
> @usr{is.the.Party.correct}
[1] FALSE
\end{rblock1}
but this doesn't:
\begin{rblock1}
> @usr{is.the.Party.correct <- f}
Error: object 'f' not found
\end{rblock1}

\subsection{Vectors of logicals}

The next thing to mention is that you can store vectors of logical values in exactly the same way that you can store vectors of numbers (Section~\ref{sec:vectors}) and vectors of text data (Section~\ref{sec:text}). Again, we can define them directly via the \rtext{c()} function, like this:
\begin{rblock1}
> @usr{x <- c(TRUE, TRUE, FALSE)}
> @usr{x}
[1]  TRUE  TRUE FALSE
\end{rblock1}
or you can produce a vector of logicals by applying a logical operator to a vector. This might not make a lot of sense to you, so let's unpack it slowly. First, let's suppose we have a vector of numbers (i.e., a ``non-logical vector"). For instance, we could use the \rtext{sales.by.month} vector that we were using in Section~\ref{sec:vectors}. Suppose I wanted \R\ to tell me, for each month of the year, whether I actually sold a book in that month. I can do that by typing this: 
\begin{rblock1}
> @usr{sales.by.month > 0}
 [1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
\end{rblock1}
and again, I can store this in a vector if I want, as the example below illustrates:
\begin{rblock1}
> @usr{any.sales.this.month <- sales.by.month > 0}
> @usr{any.sales.this.month}
 [1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
\end{rblock1}
In other words, \rtext{any.sales.this.month} is a logical vector whose elements are \rtext{TRUE} only if the corresponding element of \rtext{sales.by.month} is greater than zero. For instance, since I sold zero books in January, the first element is \rtext{FALSE}. 


\subsection{Applying logical operation to text~\label{sec:logictext}}

In a moment (Section~\ref{sec:indexing}) I'll show you why these logical operations and logical vectors are so handy, but before I do so I want to very briefly point out that you can apply them to text as well as to logical data. It's just that we need to be a bit more careful in understanding how \R\ interprets the different operations. In this section I'll talk about how the equal to operator \rtext{==} applies to text, since this is the most important one. Obviously, the not equal to operator \rtext{!=} gives the exact opposite answers to \rtext{==} so I'm implicitly talking about that one too, but I won't give specific commands showing the use of \rtext{!=}. 
%As for the other operators, I'll defer a more detailed discussion of this topic to Section~\ref{sec:logictext2}. 

Okay, let's see how it works. In one sense, it's very simple. For instance, I can ask \R\ if the word \rtext{"cat"} is the same as the word \rtext{"dog"}, like this:
\begin{rblock1}
> @usr{"cat" == "dog"}
[1] FALSE
\end{rblock1}
That's pretty obvious, and it's good to know that even \R\ can figure that out. Similarly, \R\ does recognise that a \rtext{"cat"} is a \rtext{"cat"}:
\begin{rblock1}
> @usr{"cat" == "cat"}
[1] TRUE
\end{rblock1}
Again, that's exactly what we'd expect. However, what you need to keep in mind is that \R\ is not at all tolerant when it comes to grammar and spacing. If two strings differ in any way whatsoever, \R\ will say that they're not equal to each other, as the following examples indicate:
\begin{rblock1}
> @usr{" cat" == "cat"}
[1] FALSE
> @usr{"cat" == "CAT"}
[1] FALSE
> @usr{"cat" == "c a t"}
[1] FALSE
\end{rblock1}



\section{Indexing vectors~\label{sec:indexing}} 

So far, whenever I've had to get information out of a vector, all I've done is typed something like \rtext{months[4]}; and when I do this \R\ prints out the fourth element of the \rtext{months} vector. In this section, I'll show you two additional tricks for getting information out of the vector.

\subsection{Extracting multiple elements}

One very useful thing we can do is pull out more than one element at a time. In the previous example, we only used a single number (i.e., \rtext{2}) to indicate which element we wanted. Alternatively, we can use a vector. So, suppose I wanted the data for February, March and April. What I could do is use the vector \rtext{c(2,3,4)} to indicate which elements I want \R\ to pull out. That is, I'd type this:
\begin{rblock1}
> @usr{sales.by.month[ c(2,3,4) ]}
[1] 100 200  50
\end{rblock1}
Notice that the order matters here. If I asked for the data in the reverse order (i.e., April first, then March, then February) by using the vector \rtext{c(4,3,2)}, then \R\ outputs the data in the reverse order:
\begin{rblock1}
 > @usr{sales.by.month[ c(4,3,2) ]}
[1]  50 200 100
\end{rblock1}

A second thing to be aware of is that \R\ provides you with handy shortcuts for very common situations. For instance, suppose that I wanted to extract everything from the 2nd month through to the 8th month. One way to do this is to do the same thing I did above, and use the vector \rtext{c(2,3,4,5,6,7,8)} to indicate the elements that I want. That works just fine
\begin{rblock1}
> @usr{sales.by.month[ c(2,3,4,5,6,7,8) ]}
[1] 100 200  50   0   0   0   0
\end{rblock1}
but it's kind of a lot of typing. To help make this easier, \R\ lets you use \rtext{2:8} as shorthand for \rtext{c(2,3,4,5,6,7,8)}, which makes things a lot simpler. First, let's just check that this is true:
\begin{rblock1}
> @usr{2:8}
[1] 2 3 4 5 6 7 8
\end{rblock1}
Next, let's check that we can use the \rtext{2:8} shorthand as a way to pull out the 2nd through 8th elements of \rtext{sales.by.months}:
\begin{rblock1}
> @usr{sales.by.month[2:8]}
[1] 100 200  50   0   0   0   0
\end{rblock1}
So that's kind of neat.

\subsection{Logical indexing}

At this point, I can introduce an extremely useful tool called \keyterm{logical indexing}. In the last section, I created a logical vector \rtext{any.sales.this.month}, whose elements are \rtext{TRUE} for any month in which I sold at least one book, and \rtext{FALSE} for all the others. However, that big long list of \rtext{TRUE}s and \rtext{FALSE}s is a little bit hard to read, so what I'd like to do is to have \R\ select the names of the \rtext{months} for which I sold any books. Earlier on, I created a vector \rtext{months} that contains the names of each of the months. This is where logical indexing is handy. What I need to do is this:
\begin{rblock1}
> @usr{months[ sales.by.month > 0 ]}
[1] "February" "March"    "April"    "May" 
\end{rblock1}
To understand what's happening here, it's helpful to notice that \rtext{sales.by.month > 0} is the same logical expression that we used to create the \rtext{any.sales.this.month} vector in the last section. In fact, I could have just done this:
\begin{rblock1}
> @usr{months[ any.sales.this.month ]}
[1] "February" "March"    "April"    "May" 
\end{rblock1}
and gotten exactly the same result. In order to figure out which elements of \rtext{months} to include in the output, what \R\ does is look to see if the corresponding element in \rtext{any.sales.this.month} is \rtext{TRUE}. Thus, since element 1 of \rtext{any.sales.this.month} is \rtext{FALSE}, \R\ does not include \rtext{"January"} as part of the output; but since element 2 of \rtext{any.sales.this.month} is \rtext{TRUE}, \R\ does include \rtext{"February"} in the output. Note that there's no reason why I can't use the same trick to find the actual sales numbers for those months. The command to do that would just be this:
\begin{rblock1}
> @usr{sales.by.month [ sales.by.month > 0 ]}
[1] 100 200  50  25
\end{rblock1}
In fact, we can do the same thing with text. Here's an example. Suppose that I later find out that the bookshop only had sufficient stocks for a few months of the year. They tell me that early in the year they had \rtext{"high"} stocks, which then dropped to \rtext{"low"} levels, and in fact for one month they were \rtext{"out"} of copies of the book for a while before they were able to replenish them. Thus, I might have a variable called \rtext{stock.levels} which looks like this:
\begin{rblock1}
> @usr{stock.levels}
 [1] "high" "high" "low"  "out"  "out"  "high" "high" "high" "high" "high" "high"
[12] "high"
\end{rblock1}
Thus, if I want to know the months for which the bookshop was out of my book, I could apply the logical indexing trick, but with the character vector \rtext{stock.levels}, like this:
\begin{rblock1}
> @usr{months[stock.levels == "out"]}
[1] "April" "May"  
\end{rblock1}
Alternatively, if I want to know when the bookshop was either low on copies or out of copies, I could do this:
\begin{rblock1}
> @usr{months[stock.levels == "out" | stock.levels == "low"]}
[1] "March" "April" "May"  
\end{rblock1}
or this
\begin{rblock1}
> @usr{months[stock.levels != "high" ]}
[1] "March" "April" "May"  
\end{rblock1}
Either way, I get the answer I want.

At this point, I hope you can see why logical indexing is such a useful thing. It's a very basic, yet very powerful way to manipulate data. We do not talk about how to manipulate data in this short introduction. 

\section{Quitting \R}

Assuming you're running \R\ in the usual way (i.e., through \Rstudio or the default GUI on a Windows or Mac computer), then you can just shut down the application in the normal way. However, \R\ also has a function, called \rtext{q()} that you can use to quit.

Regardless of what method you use to quit \R, when you do so for the first time \R\ will probably ask you if you want to save the ``workspace image''. We'll talk a lot more about loading and saving data in Section~\ref{sec:load}, but I figured we'd better quickly cover this now otherwise you're going to get annoyed when you close \R\ at the end of the chapter. If you're using \Rstudio, you'll see a dialog box that asks you \textit{Save workspace ...?}  and if you're using a text based interface you'll see this:
\begin{rblock1}
> @usr{q()}
Save workspace image? [y/n/c]: 
\end{rblock1}
The \rtext{y/n/c} part here is short for ``yes / no / cancel''. Type \rtext{y} if you want to save, \rtext{n} if you don't, and \rtext{c} if you've changed your mind and you don't want to quit after all. 

What does this actually {\it mean}? What's going on is that \R\ wants to know if you want to save all those variables that you've been creating, so that you can use them later. This sounds like a great idea, so it's really tempting to type \rtext{y} or click the ``Save'' button. To be honest though, I very rarely do this, and it kind of annoys me a little bit... what \R\ is {\it really} asking is if you want it to store these variables in a ``default'' data file, which it will automatically reload for you next time you open \R. And quite frankly, if I'd wanted to save the variables, then I'd have already saved them before trying to quit. Not only that, I'd have saved them to a location of {\it my} choice, so that I can find it again later.


%\begin{figure}
%\begin{center}
%		\includegraphics[width=.5\linewidth]{$HOME/Dropbox/hsf/pic/Rstudio/Rstudio_options}
%\caption{The options window in Rstudio. On a Mac, you can open this window by going to the ``Rstudio'' menu and selecting ``Preferences''. On a Windows machine you go to the ``Tools'' menu and select ``Global Options''.}
%\label{fig:Rstudiooptions}
%\end{center}
%\end{figure}

\section{Summary}\label{sec:summary2}

This chapter covered the following topics:

\begin{itemize}
\item {\it Getting started}. We downloaded and installed \R\ and Rstudio (Section~\ref{sec:gettingR}).
\item {\it Basic commands}. We talked a bit about the logic of how \R\ works and in particular how to type commands into the \R\ console (Section~\ref{sec:firstcommand}), and in doing so learned how to perform basic calculations using the arithmetic operators \rtext{+}, \rtext{-}, \rtext{*}, \rtext{/} and \rtextverb#^#. (Section~\ref{sec:arithmetic})
\item {\it Introduction to functions}. We saw several different functions, three that are used to perform numeric calculations (\rtext{sqrt()}, \rtext{abs()}, \rtext{round()}; Section~\ref{sec:usingfunctions}), one that applies to text (\rtext{nchar()}; Section~\ref{sec:simpletext}), and one that works on any variable (\rtext{length()}; Section~\ref{sec:veclength}). In doing so, we talked a bit about  how argument names work, and learned about default values for arguments. (Section~\ref{sec:functionarguments})
\item {\it Introduction to variables}. We learned the basic idea behind variables, and how to assign values to variables using the assignment operator \rtext{<-} (Section~\ref{sec:assign}). We also learned how to create vectors using the combine function \rtext{c()}. (Section~\ref{sec:vectors}) 
\item {\it Data types}. Learned the distinction between numeric, character and logical data; including the basics of how to enter and use each of them. (Sections~\ref{sec:assign} to \ref{sec:logicals})
\item {\it Logical operations}. Learned how to use the logical operators \rtext{==}, \rtext{!=}, \rtext{<}, \rtext{>}, \rtext{<=}, \rtext{=>}, \rtext{!}, \rtextverb#&# and \rtext{|}. (Section~\ref{sec:logicals}). And learned how to use logical indexing. (Section~\ref{sec:indexing})
\end{itemize}



